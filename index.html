<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online X-O Game (Tic-Tac-Toe)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Phosphor Icons for UI elements -->
    <script src="https://unpkg.com/@phosphor-icons/web@2.1.1/dist/index.umd.js"></script>
    
    <!-- STYLES.CSS Logic (Internalized) -->
    <style>
        /* Custom styles for the board and mobile layout */
        #game-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            aspect-ratio: 1 / 1; /* Ensures board is always square */
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem; /* Larger for better touch target */
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            user-select: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .cell:hover:not(:empty) {
            transform: scale(1.05);
        }

        /* X and O colors */
        .cell-x { color: #34D399; } /* Emerald 400 */
        .cell-o { color: #60A5FA; } /* Blue 400 */

        /* Video Feed Styling */
        .video-feed {
            width: 100%;
            height: 100%;
            background: #1F2937;
            border-radius: 0.5rem;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror for selfie view */
        }
        
        .chat-control-icon {
            font-size: 1.25rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen p-4 font-sans flex items-center justify-center">

    <!-- Increased max-width for better laptop layout -->
    <div id="app" class="w-full max-w-6xl space-y-6"> 
        <header class="text-center mb-6">
            <h1 class="text-4xl font-extrabold text-indigo-400">Online X-O (Tic-Tac-Toe)</h1>
            <p id="user-info" class="text-sm text-gray-400 mt-2"></p>
        </header>

        <!-- Main Content Area: Divided for Game/Video and Controls -->
        <div class="flex flex-col lg:flex-row gap-6">

            <!-- 1. Video and Game Board Container -->
            <div class="lg:w-2/3 flex flex-col gap-4">
                
                <!-- Video Feeds - Visibility controlled by JS based on mode -->
                <div id="video-feeds" class="flex gap-4 h-48 sm:h-64 hidden">
                    <div class="flex-1 bg-gray-800 rounded-xl shadow-lg p-2 relative">
                        <video id="local-video" class="video-feed" autoplay playsinline muted></video>
                        <span class="absolute top-2 left-3 text-xs bg-indigo-500 px-2 py-0.5 rounded-full">You</span>
                    </div>
                    <div class="flex-1 bg-gray-800 rounded-xl shadow-lg p-2 relative">
                        <video id="remote-video" class="video-feed" autoplay playsinline></video>
                        <span class="absolute top-2 left-3 text-xs bg-green-500 px-2 py-0.5 rounded-full">Opponent</span>
                    </div>
                </div>

                <!-- Game Status and Board -->
                <div class="bg-gray-800 rounded-xl shadow-2xl p-6 flex flex-col items-center">
                    <p id="game-status" class="text-2xl font-bold mb-4 h-8 text-center text-indigo-300">
                        Loading...
                    </p>

                    <div id="game-board" class="border-4 border-gray-700 rounded-lg">
                        <!-- Cells generated by JavaScript -->
                    </div>
                </div>

            </div>

            <!-- 2. Controls and Room Management (lg:w-1/3) -->
            <div id="controls" class="lg:w-1/3 bg-gray-800 rounded-xl shadow-lg p-6 space-y-6">
                
                <!-- Room Status -->
                <div class="text-center p-3 bg-gray-700 rounded-lg shadow-inner">
                    <p class="font-semibold text-gray-300">Mode/Room:</p>
                    <p id="room-display" class="text-3xl font-mono tracking-wider text-green-400 truncate mt-1">---</p>
                    <button id="copy-btn" class="text-sm text-indigo-400 hover:text-indigo-300 mt-2 hidden" onclick="copyRoomCode()">
                        <i class="ph-copy-bold chat-control-icon align-middle mr-1"></i> Copy Code
                    </button>
                </div>

                <!-- Connection Controls -->
                <div id="game-setup-controls" class="space-y-3">
                    <h2 class="text-xl font-semibold border-b border-gray-700 pb-2 text-indigo-300">Start a Game</h2>
                    
                    <!-- Difficulty Selector -->
                    <div class="space-y-2">
                        <label for="robot-level" class="block text-gray-300 font-medium">Robot Difficulty:</label>
                        <select id="robot-level" class="w-full p-3 rounded-lg bg-gray-700 text-white focus:ring-2 focus:ring-fuchsia-500 focus:border-transparent">
                            <option value="easy">Easy (Random)</option>
                            <option value="medium" selected>Medium (Block/Center)</option>
                            <option value="hard">Hard (Heuristic)</option>
                        </select>
                    </div>

                    <!-- Play with Robot Button -->
                    <button id="robot-btn" class="w-full py-3 bg-fuchsia-600 hover:bg-fuchsia-500 rounded-lg font-bold transition-all shadow-md" onclick="startRobotGame()">
                        <i class="ph-robot-bold chat-control-icon align-middle mr-2"></i> Play with Robot
                    </button>
                    
                    <p class="text-center text-gray-400 pt-2">--- OR Play Online ---</p>

                    <!-- Online Controls Wrapper -->
                    <div id="online-controls" class="space-y-3">
                        <button id="create-btn" class="w-full py-3 bg-indigo-600 hover:bg-indigo-500 rounded-lg font-bold transition-all shadow-md" onclick="createRoom()">
                            <i class="ph-key-bold chat-control-icon align-middle mr-2"></i> Create Private Room
                        </button>
                        
                        <div class="flex gap-2">
                            <input type="text" id="room-input" placeholder="Enter Room Code" class="flex-1 p-3 rounded-lg bg-gray-700 text-white placeholder-gray-400 focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                            <button id="join-btn" class="py-3 px-4 bg-green-600 hover:bg-green-500 rounded-lg font-bold transition-all shadow-md" onclick="joinRoom(document.getElementById('room-input').value)">
                                Join
                            </button>
                        </div>
                        
                        <p class="text-center text-gray-400 pt-2">--- OR ---</p>
                        
                        <button id="random-btn" class="w-full py-3 bg-yellow-600 hover:bg-yellow-500 rounded-lg font-bold transition-all shadow-md" onclick="findRandomGame()" disabled>
                            <i class="ph-shuffle-bold chat-control-icon align-middle mr-2"></i> Find Random Match (Experimental)
                        </button>
                    </div> <!-- End online-controls -->
                </div>

                <!-- Video/Audio Controls -->
                <div id="media-controls" class="space-y-3 pt-4 border-t border-gray-700 hidden">
                    <h2 class="text-xl font-semibold text-indigo-300">Call Controls</h2>
                    <div class="flex gap-3">
                        <button id="video-btn" class="flex-1 py-3 bg-red-600 hover:bg-red-500 rounded-lg font-bold transition-all" onclick="toggleVideo()">
                            <i class="ph-video-camera-slash-bold chat-control-icon align-middle mr-2"></i> Video OFF
                        </button>
                        <button id="audio-btn" class="flex-1 py-3 bg-red-600 hover:bg-red-500 rounded-lg font-bold transition-all" onclick="toggleAudio()">
                            <i class="ph-microphone-slash-bold chat-control-icon align-middle mr-2"></i> Audio OFF
                        </button>
                    </div>
                    <button id="start-call-btn" class="w-full py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold transition-all" onclick="startMediaAndCall()">
                        <i class="ph-phone-call-bold chat-control-icon align-middle mr-2"></i> Start Call
                    </button>
                </div>

                <!-- Reset Button -->
                <button id="reset-btn" class="w-full py-3 bg-gray-600 hover:bg-gray-500 rounded-lg font-bold transition-all mt-4" onclick="resetGame()">
                    Back to Lobby
                </button>
            </div>
        </div>
    </div>

    <!-- GAME.JS Logic (Internalized) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, runTransaction, updateDoc, deleteDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Initialization and Global State Setup ---
        
        // Global variables provided by the environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Global Firebase instances and state
        let app, db, auth;
        let userId = null;
        let unsubscribeGame = null;

        // Game State
        window.gameState = {
            board: ['', '', '', '', '', '', '', '', ''],
            players: { X: null, O: null },
            turn: 'X',
            status: 'lobby',   // 'lobby', 'waiting', 'playing', 'finished'
            mode: 'lobby',     // 'lobby', 'online', 'vs_robot'
            roomCode: null,
            isMyTurn: false,
            mySymbol: null, 
            robotDifficulty: 'medium', // New state variable for robot level
            localStream: null,
            peerConnection: null,
            isCalling: false,
            videoEnabled: true,
            audioEnabled: true,
            remotePlayerId: null 
        };
        
        // --- Utility Functions ---

        /** Generates a simple 6-character room code. */
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        /** Copies the room code to the clipboard. */
        window.copyRoomCode = function() {
            const roomCode = window.gameState.roomCode;
            if (roomCode) {
                // Clipboard copy logic
                navigator.clipboard.writeText(roomCode).then(() => {
                    console.log('Room code copied to clipboard!');
                    const btn = document.getElementById('copy-btn');
                    const originalText = btn.innerHTML;
                    btn.innerHTML = '<i class="ph-check-bold chat-control-icon align-middle mr-1"></i> Copied!';
                    setTimeout(() => { btn.innerHTML = originalText; }, 1500);
                }).catch(err => {
                    // Fallback for iFrame restrictions
                    document.execCommand('copy');
                    console.error('Could not copy text (used fallback): ', err);
                });
            }
        };

        /** Checks for a winner or a draw. */
        function checkWin(board) {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a]; // Returns 'X' or 'O'
                }
            }

            if (board.every(cell => cell !== '')) {
                return 'Draw'; // Returns 'Draw'
            }

            return null;
        }

        /** Updates the main UI elements based on the current game state. */
        function updateUI() {
            const { board, turn, status, roomCode, mySymbol, isMyTurn, mode, robotDifficulty } = window.gameState;
            const gameStatusEl = document.getElementById('game-status');
            const roomDisplayEl = document.getElementById('room-display');
            const copyBtn = document.getElementById('copy-btn');
            const boardEl = document.getElementById('game-board');
            const mediaControls = document.getElementById('media-controls');
            const videoFeeds = document.getElementById('video-feeds');

            // 1. Mode/Room Status Display
            if (mode === 'vs_robot') {
                roomDisplayEl.textContent = `ROBOT (${robotDifficulty.toUpperCase()})`;
            } else if (roomCode) {
                roomDisplayEl.textContent = roomCode;
            } else {
                roomDisplayEl.textContent = '---';
            }
            copyBtn.classList.toggle('hidden', mode !== 'online' || !roomCode);
            
            // 2. Control Visibility
            const isOnlineMode = mode === 'online';
            // Hide online controls once a game (robot or online) has started
            const inLobby = mode === 'lobby';
            document.getElementById('game-setup-controls').classList.toggle('hidden', !inLobby);
            
            // Show media controls and video feeds only in online mode
            mediaControls.classList.toggle('hidden', !isOnlineMode);
            videoFeeds.classList.toggle('hidden', !isOnlineMode); // FIX for Laptop screen space

            // 3. Board Rendering
            boardEl.innerHTML = board.map((cell, index) => 
                `<div class="cell bg-gray-700 hover:bg-gray-600 active:bg-gray-500 border-gray-600 ${cell === 'X' ? 'cell-x' : cell === 'O' ? 'cell-o' : ''} ${isMyTurn && cell === '' ? 'cursor-pointer' : 'cursor-default'}" 
                      data-index="${index}" 
                      onclick="makeMove(${index})">
                    ${cell}
                </div>`
            ).join('');

            // 4. Status Message
            let statusText = 'Lobby: Select a game mode';
            let color = 'text-indigo-300';
            const winner = checkWin(board); 

            if (mode === 'vs_robot') {
                if (status === 'playing') {
                    statusText = isMyTurn ? 'Your Turn (X)' : 'Robot is thinking... (O)';
                    color = isMyTurn ? 'text-green-400' : 'text-red-400';
                } else if (status === 'finished') {
                    if (winner === 'Draw') {
                        statusText = 'Game Over: Draw!';
                        color = 'text-gray-300';
                    } else if (winner === mySymbol) {
                        statusText = 'Game Over: You Win!';
                        color = 'text-green-500';
                    } else {
                        statusText = `Game Over: Robot (${robotDifficulty.toUpperCase()}) Wins!`;
                        color = 'text-red-500';
                    }
                }
            } else if (isOnlineMode) {
                if (status === 'waiting') {
                    statusText = `Waiting for Player ${mySymbol === 'X' ? 'O' : 'X'} to Join...`;
                    color = 'text-yellow-400';
                } else if (status === 'playing') {
                    if (isMyTurn) {
                        statusText = `Your Turn (${mySymbol})!`;
                        color = (mySymbol === 'X' ? 'text-green-400' : 'text-blue-400');
                    } else {
                        statusText = `Opponent's Turn (${turn}).`;
                        color = 'text-red-400';
                    }
                } else if (status === 'finished') {
                    if (winner === 'Draw') {
                        statusText = 'Game Over: It\'s a Draw!';
                        color = 'text-gray-300';
                    } else {
                        statusText = `Game Over: ${winner} Wins!`;
                        color = winner === mySymbol ? 'text-green-500' : 'text-red-500';
                    }
                }
            }

            gameStatusEl.textContent = statusText;
            gameStatusEl.className = `text-2xl font-bold mb-4 h-8 text-center ${color}`;
        }

        // --- Robot AI Logic ---

        /** Finds the best move for the robot ('O') using selected difficulty. */
        function getRobotMove(board, robotSymbol, difficulty) {
            const humanSymbol = robotSymbol === 'X' ? 'O' : 'X';
            const availableMoves = board.map((cell, index) => cell === '' ? index : null).filter(i => i !== null);
            
            if (availableMoves.length === 0) return -1;
            
            // --- EASY MODE: Pure Random ---
            if (difficulty === 'easy') {
                return availableMoves[Math.floor(Math.random() * availableMoves.length)];
            }

            // --- MEDIUM/HARD MODE: Heuristic Logic ---
            function canWin(testBoard, symbol, moveIndex) {
                const tempBoard = [...testBoard];
                tempBoard[moveIndex] = symbol;
                return checkWin(tempBoard) === symbol;
            }
            
            // 1. Check for immediate robot win (Aggressive move)
            for (const i of availableMoves) {
                if (canWin(board, robotSymbol, i)) return i;
            }

            // 2. Block immediate human win (Defensive move)
            let shouldBlock = true;
            if (difficulty === 'medium' && Math.random() < 0.3) {
                // 30% chance Medium robot misses the block
                shouldBlock = false;
            }
            
            if (shouldBlock || difficulty === 'hard') {
                for (const i of availableMoves) {
                    if (canWin(board, humanSymbol, i)) return i;
                }
            }

            // 3. Take the center (Index 4)
            if (availableMoves.includes(4)) return 4;

            // 4. Take a corner (0, 2, 6, 8)
            const corners = [0, 2, 6, 8];
            const availableCorners = availableMoves.filter(i => corners.includes(i));
            if (availableCorners.length > 0) {
                // Choose a random available corner
                return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            }

            // 5. Take any remaining side spot (randomly)
            const sides = [1, 3, 5, 7];
            const availableSides = availableMoves.filter(i => sides.includes(i));
            if (availableSides.length > 0) {
                return availableSides[Math.floor(Math.random() * availableSides.length)];
            }

            return -1; 
        }


        // --- Game Flow Functions ---

        /** Starts a single-player game against the Robot. */
        window.startRobotGame = function() {
            window.resetGame(false); 
            
            const difficultySelector = document.getElementById('robot-level');
            const selectedDifficulty = difficultySelector ? difficultySelector.value : 'medium';

            window.gameState.mode = 'vs_robot';
            window.gameState.mySymbol = 'X'; 
            window.gameState.players = { X: 'human', O: 'robot' };
            window.gameState.turn = 'X';
            window.gameState.isMyTurn = true;
            window.gameState.status = 'playing';
            window.gameState.robotDifficulty = selectedDifficulty;

            updateUI();
        };

        /** Handles local move and updates game state (robot or online). */
        window.makeMove = async function(index) {
            let { mySymbol, board, turn, status, mode } = window.gameState;

            if (status !== 'playing' || !window.gameState.isMyTurn || board[index] !== '') {
                console.log("Invalid move or not your turn.");
                return;
            }
            
            // --- HUMAN MOVE ---
            let newBoard = [...board];
            newBoard[index] = mySymbol;
            let winner = checkWin(newBoard);
            let newTurn = mySymbol === 'X' ? 'O' : 'X';
            let newStatus = winner ? 'finished' : 'playing';

            // Update local state temporarily for UI responsiveness
            window.gameState.board = newBoard;
            window.gameState.turn = newTurn;
            window.gameState.status = newStatus;
            window.gameState.isMyTurn = false;
            updateUI(); 

            if (mode === 'vs_robot') {
                if (newStatus === 'finished') return; 
                
                // Set turn display to Robot's turn
                window.gameState.turn = 'O';
                updateUI(); 

                await new Promise(r => setTimeout(r, 700));

                // --- ROBOT MOVE ---
                const robotSymbol = 'O'; 
                const robotMoveIndex = getRobotMove(newBoard, robotSymbol, window.gameState.robotDifficulty);

                if (robotMoveIndex !== -1) {
                    newBoard[robotMoveIndex] = robotSymbol;
                    winner = checkWin(newBoard);
                    newTurn = mySymbol; 
                    newStatus = winner ? 'finished' : 'playing';

                    window.gameState.board = newBoard;
                    window.gameState.turn = newTurn;
                    window.gameState.status = newStatus;
                    window.gameState.isMyTurn = (newStatus === 'playing'); 
                    updateUI();
                }

            } else if (mode === 'online') {
                // Online mode: Send move to Firestore
                const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', window.gameState.roomCode);

                try {
                    await setDoc(roomDocRef, {
                        board: newBoard,
                        turn: newTurn,
                        status: newStatus,
                        winner: winner || null,
                        // CRITICAL FIX: Removed arrayRemove/arrayUnion here to ensure
                        // WebRTC signaling is not interrupted by game moves.
                    }, { merge: true });
                } catch (error) {
                    console.error("Error updating game state (Online mode):", error);
                }
            }
        };

        /** Subscribes to the game document for real-time updates (Online Mode Only). */
        function subscribeToGame(roomCode) {
            if (unsubscribeGame) unsubscribeGame();
            window.gameState.mode = 'online'; 
            
            const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', roomCode);

            unsubscribeGame = onSnapshot(roomDocRef, (docSnap) => {
                if (!docSnap.exists()) {
                    console.error("Game room disappeared.");
                    window.resetGame(false);
                    return;
                }
                
                const data = docSnap.data();
                
                window.gameState.board = data.board || window.gameState.board;
                window.gameState.turn = data.turn || 'X';
                window.gameState.status = data.status || 'playing';
                window.gameState.players = data.players || { X: null, O: null };
                
                const { players, turn, status } = window.gameState;
                window.gameState.mySymbol = players.X === userId ? 'X' : players.O === userId ? 'O' : null;
                window.gameState.isMyTurn = (window.gameState.mySymbol && turn === window.gameState.mySymbol && status === 'playing');
                window.gameState.remotePlayerId = window.gameState.mySymbol === 'X' ? players.O : players.X;
                
                updateUI();
                
                // Only handle signaling if both players are present
                if (players.X && players.O) {
                    handleSignaling(data);
                }

            }, (error) => {
                console.error("Error listening to game state:", error);
            });
            
            // Note: window.gameState.roomCode is already set in createRoom/joinRoom
        }

        /** Creates a new game room (Online Mode Only). */
        window.createRoom = async function() {
            window.resetGame(false); 

            const newCode = generateRoomCode();
            const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', newCode);

            // FIX: Check for userId availability and give better feedback
            if (!userId) { 
                document.getElementById('game-status').textContent = 'Error: Authentication not complete. Please wait a moment.';
                console.error("User not authenticated."); 
                return; 
            }

            try {
                // FIX: Set local roomCode immediately for responsive UI update
                window.gameState.roomCode = newCode;
                window.gameState.mySymbol = 'X';
                window.gameState.status = 'waiting';

                await setDoc(roomDocRef, {
                    board: ['', '', '', '', '', '', '', '', ''],
                    players: { X: userId, O: null },
                    turn: 'X',
                    status: 'waiting',
                    winner: null,
                    createdAt: new Date().getTime(),
                    // Initialize signaling arrays
                    [`webrtc_${userId}`]: [],
                });
                
                subscribeToGame(newCode);
                updateUI(); // Immediate UI update to show room code

            } catch (error) {
                console.error("Error creating room:", error);
                document.getElementById('game-status').textContent = 'Error: Failed to create room. Check Firestore permissions.';
            }
        };

        /** Joins an existing game room (Online Mode Only). */
        window.joinRoom = async function(roomCode) {
            roomCode = roomCode.toUpperCase().trim();
            if (!roomCode || roomCode.length < 6) { 
                document.getElementById('game-status').textContent = 'Please enter a valid 6-character room code.';
                return;
            }
            const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', roomCode);

            if (!userId) { console.error("User not authenticated."); return; }

            try {
                await runTransaction(db, async (transaction) => {
                    const docSnap = await transaction.get(roomDocRef);

                    if (!docSnap.exists()) {
                        throw new Error("Room does not exist.");
                    }

                    const data = docSnap.data();
                    if (data.players.O) {
                        throw new Error("Room is already full.");
                    }
                    if (data.players.X === userId) {
                        throw new Error("You are already Player X in this room.");
                    }

                    transaction.update(roomDocRef, {
                        'players.O': userId,
                        status: 'playing',
                        // Initialize signaling array for the joining player
                        [`webrtc_${userId}`]: [], 
                    });
                });

                window.gameState.mySymbol = 'O';
                window.gameState.status = 'playing';
                subscribeToGame(roomCode);

            } catch (error) {
                console.error("Error joining room:", error.message);
                document.getElementById('game-status').textContent = `Error joining: ${error.message}`;
            }
        };

        /** Resets the game locally and cleans up remote connection/data. */
        window.resetGame = async function(shouldResetRemote = true) {
            const { roomCode, mySymbol, mode } = window.gameState;
            
            if (unsubscribeGame) { unsubscribeGame(); unsubscribeGame = null; }
            endCall();

            if (shouldResetRemote && roomCode && mySymbol === 'X' && mode === 'online') {
                try {
                    const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', roomCode);
                    await deleteDoc(roomDocRef);
                } catch (error) {
                    console.error("Could not delete room:", error);
                }
            }
            
            // Reset local state to initial values
            window.gameState = {
                board: ['', '', '', '', '', '', '', '', ''],
                players: { X: null, O: null },
                turn: 'X',
                status: 'lobby',
                mode: 'lobby', 
                roomCode: null,
                isMyTurn: false,
                mySymbol: null,
                robotDifficulty: 'medium', // Reset to default
                localStream: null,
                peerConnection: null,
                isCalling: false,
                videoEnabled: true,
                audioEnabled: true,
                remotePlayerId: null 
            };
            
            updateUI();
        };


        // --- WebRTC (Video/Audio) Logic ---

        const servers = {
            iceServers: [
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
            ]
        };
        
        const mediaConstraints = { video: true, audio: true };
        
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const videoBtn = document.getElementById('video-btn');
        const audioBtn = document.getElementById('audio-btn');
        const startCallBtn = document.getElementById('start-call-btn');

        /** Starts media stream and enables call controls. */
        window.startMediaAndCall = async function() {
            if (window.gameState.isCalling) return;
            
            try {
                window.gameState.localStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
                localVideo.srcObject = window.gameState.localStream;
                window.gameState.isCalling = true;
                
                // Update UI for media controls
                videoBtn.classList.replace('bg-red-600', 'bg-green-600');
                videoBtn.innerHTML = '<i class="ph-video-camera-bold chat-control-icon align-middle mr-2"></i> Video ON';
                
                audioBtn.classList.replace('bg-red-600', 'bg-green-600');
                audioBtn.innerHTML = '<i class="ph-microphone-bold chat-control-icon align-middle mr-2"></i> Audio ON';
                
                startCallBtn.classList.add('hidden');

                if (window.gameState.mode === 'online' && window.gameState.roomCode && window.gameState.status === 'playing') {
                    // O is the caller in this implementation, which handles the joining process.
                    const isCaller = window.gameState.mySymbol === 'O'; 
                    startCall(isCaller); 
                }

            } catch (err) {
                console.error("Error accessing media devices:", err);
                document.getElementById('game-status').textContent = "Error: Could not access camera/microphone. Check permissions.";
                window.gameState.isCalling = false;
            }
        };

        /** Toggles the local video track. */
        window.toggleVideo = function() {
            if (!window.gameState.localStream) return;
            window.gameState.videoEnabled = !window.gameState.videoEnabled;
            const track = window.gameState.localStream.getVideoTracks()[0];
            if (track) { track.enabled = window.gameState.videoEnabled; }

            videoBtn.classList.toggle('bg-red-600', !window.gameState.videoEnabled);
            videoBtn.classList.toggle('bg-green-600', window.gameState.videoEnabled);
            videoBtn.innerHTML = window.gameState.videoEnabled 
                ? '<i class="ph-video-camera-bold chat-control-icon align-middle mr-2"></i> Video ON' 
                : '<i class="ph-video-camera-slash-bold chat-control-icon align-middle mr-2"></i> Video OFF';
        };

        /** Toggles the local audio track. */
        window.toggleAudio = function() {
            if (!window.gameState.localStream) return;
            window.gameState.audioEnabled = !window.gameState.audioEnabled;
            const track = window.gameState.localStream.getAudioTracks()[0];
            if (track) { track.enabled = window.gameState.audioEnabled; }
            
            audioBtn.classList.toggle('bg-red-600', !window.gameState.audioEnabled);
            audioBtn.classList.toggle('bg-green-600', window.gameState.audioEnabled);
            audioBtn.innerHTML = window.gameState.audioEnabled
                ? '<i class="ph-microphone-bold chat-control-icon align-middle mr-2"></i> Audio ON'
                : '<i class="ph-microphone-slash-bold chat-control-icon align-middle mr-2"></i> Audio OFF';
        };
        
        /** Starts the WebRTC peer connection (requires media stream to be running). */
        async function startCall(isCaller = false) {
            if (!window.gameState.localStream || !window.gameState.roomCode || !window.gameState.remotePlayerId) {
                console.warn("Cannot start call: Media stream not running or room data incomplete.");
                return;
            }

            // Close existing connection to prevent re-use issues
            if (window.gameState.peerConnection) {
                window.gameState.peerConnection.close();
                window.gameState.peerConnection = null;
            }

            window.gameState.peerConnection = new RTCPeerConnection(servers);
            const pc = window.gameState.peerConnection;
            
            // Handle remote track/stream
            pc.ontrack = (event) => {
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                }
            };
            
            // Add local tracks
            window.gameState.localStream.getTracks().forEach(track => {
                pc.addTrack(track, window.gameState.localStream);
            });
            
            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignalingData({ type: 'candidate', candidate: event.candidate.toJSON() });
                }
            };
            
            // Create and send offer if we are the caller (Player O)
            if (isCaller) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignalingData({ type: 'offer', sdp: pc.localDescription.sdp });
                console.log("WebRTC: Sent Offer.");
            }
        }
        
        /** Sends WebRTC signaling data through Firestore. */
        async function sendSignalingData(data) {
            const { roomCode, remotePlayerId } = window.gameState;
            if (!roomCode || !remotePlayerId || window.gameState.mode !== 'online') return;

            const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', roomCode);
            const remoteField = `webrtc_${remotePlayerId}`;
            
            try {
                // Use arrayUnion to safely append the signal data
                await updateDoc(roomDocRef, {
                    [remoteField]: arrayUnion(data)
                });
            } catch (error) {
                console.error("Failed to send signaling data:", error);
            }
        }

        /** Handles incoming signaling data from Firestore. */
        async function handleSignaling(data) {
            const myField = `webrtc_${userId}`;
            const signals = data[myField] || [];
            
            if (signals.length === 0 || window.gameState.mode !== 'online') return;

            const pc = window.gameState.peerConnection;
            const roomDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'xogames', window.gameState.roomCode);

            for (const signal of signals) {
                try {
                    if (signal.type === 'offer') {
                        // If we receive an offer, we must ensure media is running and PC is set up
                        if (!window.gameState.isCalling) {
                            await window.startMediaAndCall(); 
                            await startCall(false); // Initialize PC but not as caller
                        }

                        if (pc) {
                            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: signal.sdp }));
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            sendSignalingData({ type: 'answer', sdp: pc.localDescription.sdp });
                            console.log("WebRTC: Sent Answer.");
                        }

                    } else if (signal.type === 'answer') {
                        if (pc && pc.remoteDescription === null) {
                             await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: signal.sdp }));
                             console.log("WebRTC: Received and set Answer.");
                        }

                    } else if (signal.type === 'candidate') {
                        if (pc) {
                            await pc.addIceCandidate(new RTCIceCandidate(signal.candidate));
                        }
                    }
                } catch (e) {
                    console.error("Error processing signaling data:", e);
                }
            }
            
            // Clear the processed signals from our array atomically
            if (signals.length > 0) {
                try {
                    await updateDoc(roomDocRef, { [myField]: [] });
                } catch (error) {
                    console.error("Failed to clear signaling data:", error);
                }
            }
        }

        /** Cleans up the WebRTC connection. */
        function endCall() {
            if (window.gameState.localStream) {
                window.gameState.localStream.getTracks().forEach(track => track.stop());
                window.gameState.localStream = null;
                localVideo.srcObject = null;
            }
            if (remoteVideo.srcObject) remoteVideo.srcObject = null;
            if (window.gameState.peerConnection) {
                window.gameState.peerConnection.close();
                window.gameState.peerConnection = null;
            }
            window.gameState.isCalling = false;
            
            startCallBtn.classList.remove('hidden');
            videoBtn.classList.replace('bg-green-600', 'bg-red-600');
            videoBtn.innerHTML = '<i class="ph-video-camera-slash-bold chat-control-icon align-middle mr-2"></i> Video OFF';
            
            audioBtn.classList.replace('bg-green-600', 'bg-red-600');
            audioBtn.innerHTML = '<i class="ph-microphone-slash-bold chat-control-icon align-middle mr-2"></i> Audio OFF';
        }


        // --- Initialization ---

        window.onload = async function() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                setLogLevel('debug');

                const authPromise = new Promise((resolve) => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                        }
                        unsubscribe();
                        resolve();
                    });
                });
                await authPromise;
                
                document.getElementById('user-info').textContent = `User ID: ${userId.substring(0, 8)}... (Online services require this ID)`;
                updateUI();

            } catch (error) {
                console.error("Initialization Error:", error);
                document.getElementById('game-status').textContent = 'Error: Initialization failed. Check console.';
            }
        };

    </script>
</body>
</html>
